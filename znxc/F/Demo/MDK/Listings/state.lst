C251 COMPILER V5.60.0,  state                                                              04/09/24  12:53:34  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE state
OBJECT MODULE PLACED IN .\Objects\state.obj
COMPILER INVOKED BY: D:\keilC251\C251\BIN\C251.EXE ..\CODE\state.c XSMALL INTR2 WARNINGLEVEL(3) BROWSE INCDIR(..\CODE;..
                    -\USER;..\..\lib\zf_app;..\..\lib\zf_base;..\..\lib\zf_bsp) DEBUG PRINT(.\Listings\state.lst) TABS(2) OBJECT(.\Objects\st
                    -ate.obj) 

stmt  level    source

    1          #include "headfile.h"
    2          char state[30]={Track,Track,Track,Track,Track,Track};
    3          int state_lead=0;
    4          int Flag_Circ=0;
    5          int Flag_Obstacle=0;
    6          int flag_turn=0;
    7          int typee = 0;
    8          int po_time = 0;
    9          int count_i = 0;
   10          float Sum_Distance=0,Sum_Angle=0;
   11          float BZ_sp1 = 120,BZ_err1 = 0.9,BZ_sum1 = 110,BZ_dis1 = 8500;
   12          float BZ_sp2 = 120,BZ_err2 = -0.25,BZ_sum2 = -145,BZ_dis2 = 12000;
   13          float BZ_sp3 = 120,BZ_err3 = 0.03,BZ_sum3 = 0,BZ_dis3 = 10000;
   14          float LC_dis1 = 10,LC_err2 = 0.2,LC_sum2 = 75,LC_sum3 = 1350,LC_dis4 = 55;
   15          float RC_dis1 = 10,RC_err2 = -0.3,RC_sum2 = -95,RC_sum3 = -1390,RC_dis4 = 20  ;
   16          void state_detect()
   17          {
   18   1        InductorNormal();
   19   1        switch(state[state_lead])
   20   1        {
   21   2          case Track:
   22   2            if(Track_Jump())state_lead++;break;
   23   2          case Big_Circ_Left:
   24   2            if(Big_Circ_Left_Jump(&Flag_Circ))state_lead++;break;
   25   2          case Big_Circ_Right:
   26   2            if(Big_Circ_Right_Jump(&Flag_Circ))state_lead++;break;
   27   2          case Small_Circ_Left:
   28   2            if(Small_Circ_Left_Jump(&Flag_Circ))state_lead++;break;
   29   2          case Small_Circ_Right:
   30   2            if(Small_Circ_Right_Jump(&Flag_Circ))state_lead++;break;
   31   2          case Obstacle:
   32   2            if(Obstacle_Jump(&Flag_Obstacle))state_lead++;break;  
   33   2          default:break;
   34   2        }
   35   1      }
   36          int Track_Jump()
   37          {
   38   1        switch(state[state_lead+1])
   39   1          {
   40   2            case Big_Circ_Left:
   41   2            if(L_Adc>90&&R_Adc>55)
   42   2              {Flag_Circ=1;return 1;}
   43   2                break;
   44   2            case Small_Circ_Left:
   45   2            if(L_Adc>80&&R_Adc>40&&M_Adc>60)
   46   2              {Flag_Circ=1;return 1;}
   47   2                break;
   48   2            case Big_Circ_Right:
   49   2              if(R_Adc>90&&L_Adc>5555)
   50   2              {Flag_Circ=1;return 1;}
   51   2              break;
   52   2            case Small_Circ_Right:
   53   2      //        if((temp[0]+temp[3]>3000)&&(temp[1]+temp[2]>2000))
   54   2            if(R_Adc>80&&L_Adc>40&&M_Adc>60)
   55   2              {Flag_Circ=1;return 1;}
   56   2                break;
   57   2            case Obstacle:
C251 COMPILER V5.60.0,  state                                                              04/09/24  12:53:34  PAGE 2   

   58   2              //ips114_showstr(0,4,"jinle");//½øÀ´ÁË
   59   2            if(dl1a_distance_mm<1000&&Flag_Obstacle==0 && Erro<0.3)//
   60   2            {
   61   3              Flag_Obstacle=1;
   62   3            //  ips114_showstr(0,5,"success");
   63   3            return 1;}
   64   2            break;
   65   2            case Stop:
   66   2            return 1;break;
   67   2            case Garage_In:
   68   2              if(P26==0)
   69   2              {return 1;}
   70   2              break;
   71   2            default:break;    
   72   2            }
   73   1          
   74   1      
   75   1          return 0;
   76   1      }
   77          int Small_Circ_Left_Jump(int* Flag)
   78          {
   79   1        switch((*Flag)){
   80   2          case 1:
   81   2            Sum_Distance+=(motor_L_pid.ActValue+motor_R_pid.ActValue)*isr_time*0.5;
   82   2            //P67=1;
   83   2            if(Sum_Distance>LC_dis1){
   84   3                Sum_Distance=0;
   85   3                (*Flag)++;}break;
   86   2          case 2:
   87   2            Sum_Angle+=Single_Angle_Get();
   88   2            P67=0;
   89   2            
   90   2            if(Sum_Angle>LC_sum2){
   91   3                Sum_Angle=0;
   92   3                (*Flag)++;}break;
   93   2          case 3:
   94   2            Sum_Angle+=Single_Angle_Get();
   95   2            //P67=1;
   96   2            if(Sum_Angle>LC_sum3){
   97   3                Sum_Angle=0;
   98   3                (*Flag)++;} break;
   99   2          case 4:
  100   2            Sum_Distance+=(motor_L_pid.ActValue+motor_R_pid.ActValue)*isr_time*0.5;
  101   2            typee  = 4;
  102   2            P67=0;
  103   2              if(Sum_Distance>LC_dis4){
  104   3                Sum_Distance=0;
  105   3                (*Flag)=0;
  106   3                return 1; }
  107   2          default:break;}
  108   1          return 0;
  109   1      }
  110          int Small_Circ_Right_Jump(int* Flag)
  111          {
  112   1      switch((*Flag)){
  113   2          case 1:
  114   2          //P67=1;
  115   2          Sum_Distance+=(motor_L_pid.ActValue+motor_R_pid.ActValue)*isr_time*0.5; 
  116   2          if(Sum_Distance>RC_dis1){
  117   3          Sum_Distance=0;
  118   3          (*Flag)++;}break;
  119   2          case 2:
  120   2            P67=0;
  121   2            Sum_Angle+=Single_Angle_Get();
  122   2            if(abs(Sum_Angle<RC_sum2)){
  123   3                Sum_Angle=0;
C251 COMPILER V5.60.0,  state                                                              04/09/24  12:53:34  PAGE 3   

  124   3                (*Flag)++;
  125   3              } 
  126   2              break;
  127   2          case 3:
  128   2        //  P67=1;
  129   2            Sum_Angle+=Single_Angle_Get();
  130   2            if(Sum_Angle<RC_sum3)
  131   2              {
  132   3                Sum_Angle=0;
  133   3                (*Flag)++;
  134   3                
  135   3              }break;
  136   2          case 4:
  137   2            P67=0;
  138   2            Sum_Distance+=(motor_L_pid.ActValue+motor_R_pid.ActValue)*isr_time*0.5;
  139   2              if(Sum_Distance>RC_dis4)
  140   2              {
  141   3                Sum_Distance=0;
  142   3                (*Flag)=0;
  143   3                typee  = 5;
  144   3                return 1;
  145   3              }
  146   2          default:break;
  147   2          }
  148   1      //  printf("%d\r\n",(*Flag));
  149   1        return 0;
  150   1      }
  151          int Obstacle_Jump(int *Flag)
  152          {
  153   1        switch (*Flag)
  154   1        {
  155   2          
  156   2          case 1:
  157   2            r_speed_add += r_speed_add_temp;
  158   2            Sum_Angle+=Single_Angle_Get();
  159   2            
  160   2            if(r_speed_add>BZ_dis1&&abs(Sum_Angle)>BZ_sum1)
  161   2              {
  162   3                Sum_Angle=0;
  163   3                r_speed_add=0;
  164   3                (*Flag)++;
  165   3              }break;
  166   2          case 2:
  167   2            Sum_Angle+=Single_Angle_Get();
  168   2            l_speed_add += l_speed_add_temp;
  169   2          
  170   2            Sum_Distance+=(motor_L_pid.ActValue+motor_R_pid.ActValue)*isr_time*0.5;
  171   2              if(/*l_speed_add>BZ_dis2*/Sum_Angle<BZ_sum2)
  172   2            {
  173   3              l_speed_add=0;
  174   3              r_speed_add=0;
  175   3              Sum_Angle=0;
  176   3              (*Flag)++;  
  177   3            }break;
  178   2            case 3:
  179   2            r_speed_add += r_speed_add_temp;
  180   2            
  181   2              if(r_speed_add>BZ_dis3||((L_Adc>7&&L_S_Adc>3)||(R_Adc>7&&R_S_Adc>3)))
  182   2              {   
  183   3                r_speed_add=0;
  184   3                (*Flag)++;
  185   3                
  186   3                
  187   3              }break;
  188   2            case 4:
  189   2            {
C251 COMPILER V5.60.0,  state                                                              04/09/24  12:53:34  PAGE 4   

  190   3              if((L_Adc>7&&L_S_Adc>3)||(R_Adc>7&&R_S_Adc>3))
  191   3              { 
  192   4                (*Flag)=0;
  193   4                po_time=1;
  194   4                return 1;
  195   4              }
  196   3            }break;
  197   2      
  198   2          }
  199   1        return 0;
  200   1      }
  201          
  202          int Big_Circ_Left_Jump(int* Flag)
  203          {
  204   1        
  205   1          return 0;
  206   1      }
*** WARNING C47 IN LINE 202 OF ..\CODE\state.c: 'Flag': unreferenced parameter
  207          
  208          int Big_Circ_Right_Jump(int* Flag)
  209          {
  210   1        
  211   1          return 0;
  212   1      }
*** WARNING C47 IN LINE 208 OF ..\CODE\state.c: 'Flag': unreferenced parameter
  213          //int Ramp_Jump(int *Flag)
  214          //{
  215          //  
  216          //}


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      1336     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =       140     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       268     ------
End of Module Information.


C251 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
